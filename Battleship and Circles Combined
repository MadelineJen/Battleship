
	private Color RectColor = Color.MAGENTA;
	protected ArrayList<Rectangle> rectangles = new ArrayList<>();
	private Rectangle currentDraggedRectangle = null;
	private int otherX, otherY;
	private int clickCount = 0;
	private int gridSize = 50; // Size of each grid square
	private int gridWidth = 12; // Number of grid squares in the x-direction
	private int gridHeight = 12; // Number of grid squares in the y-direction
	private boolean isDraggable = true;

	public RectangleCanvas() {
		setBackground(Color.BLUE);
		addMouseListener(this);
		addMouseMotionListener(this);
		setFocusable(true);
	}

	public void setDraggable(boolean draggable) {
		isDraggable = draggable;
	}

	public void mousePressed(MouseEvent e) {
		if (isDraggable) {
			int x = e.getX();
			int y = e.getY();
			for (Rectangle rect : rectangles) {
				if (rect.contains(x, y)) {
					currentDraggedRectangle = rect;
					otherX = x - rect.x;
					otherY = y - rect.y;
					break;
				}
			}
		}
	}

	public void mouseReleased(MouseEvent e) {
	}

	public void mouseClicked(MouseEvent e) {
		if (isDraggable && clickCount < 4) {
			int x = (e.getX() / gridSize) * gridSize;
			int y = (e.getY() / gridSize) * gridSize;
			int width = (clickCount + 1) * gridSize;
			int height = gridSize;

			// Ensures that the rectangle stays within the grid boundaries
			if (x + width > gridWidth * gridSize) {
				x = (gridWidth - (clickCount + 1)) * gridSize;
			}
			if (y + height > gridHeight * gridSize) {
				y = (gridHeight - 1) * gridSize;
			}

			Rectangle newRect = new Rectangle(x, y, width, height);

			// Check for overlap with existing rectangles
			boolean overlap = false;
			for (Rectangle existingRect : rectangles) {
				if (newRect.intersects(existingRect)) {
					overlap = true;
					break;
				}
			}

			// Add the new rectangle only if there is no overlap
			if (!overlap) {
				rectangles.add(newRect);
				clickCount++;
				repaint();
			}
		}
	}

	public void mouseDragged(MouseEvent e) {
		if (currentDraggedRectangle != null) {
			int x = e.getX();
			int y = e.getY();
			int gridX = (x / gridSize) * gridSize;
			int gridY = (y / gridSize) * gridSize;

			// Ensure that the rectangle stays within the grid boundaries
			if (gridX < 50 || gridY < 50) {
				// Prevent dragging beyond the first column or row
				return;
			}

			// Ensure that the rectangle stays within the drawn grid boundaries
			int lastDrawnLineX = (gridWidth) * gridSize;
			int lastDrawnLineY = (gridHeight) * gridSize;

			if (gridX + currentDraggedRectangle.width > lastDrawnLineX) {
				gridX = lastDrawnLineX - currentDraggedRectangle.width;
			}
			if (gridY + currentDraggedRectangle.height > lastDrawnLineY) {
				gridY = lastDrawnLineY - currentDraggedRectangle.height;
			}

			// Check for collision with existing rectangles
			boolean collision = false;
			for (Rectangle rect : rectangles) {
				if (rect != currentDraggedRectangle && rect.intersects(new Rectangle(gridX, gridY, currentDraggedRectangle.width, currentDraggedRectangle.height))) {
					collision = true;
					break;
				}
			}

			// If there is no collision, update the position
			if (!collision) {
				currentDraggedRectangle.setLocation(gridX, gridY);
				repaint();
				if (isRotateKeyPressed(e)) {
					int temp = currentDraggedRectangle.width;
					currentDraggedRectangle.width = currentDraggedRectangle.height;
					currentDraggedRectangle.height = temp;
				}
			}
		}
	}

	private boolean isRotateKeyPressed(MouseEvent e) {
		return e.isShiftDown();
	}
	public void paintComponent(Graphics g) {
		super.paintComponent(g);
		for (Rectangle rect : rectangles) {
			g.setColor(RectColor);
			g.fillRect(rect.x, rect.y, rect.width, rect.height);
		}
	}

	public void mouseEntered(MouseEvent e) {
	}

	public void mouseExited(MouseEvent e) {
	}

	public void mouseMoved(MouseEvent e) {
	}

}
