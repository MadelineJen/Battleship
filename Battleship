
import java.util.List;
import java.util.ArrayList;
import java.awt.Graphics;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Rectangle;
import javax.swing.JFrame;
import javax.swing.JPanel;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseEvent;
import javax.swing.JButton;

public class Battleship {
    public static void main(String[] args) {
        JFrame frame = new JFrame("Battleship Game");
        RectangleCanvas canvas = new RectangleCanvas();
        Grids grid = new Grids(canvas); // Pass the canvas reference to Grids
        JButton confirmButton = new JButton("Confirm");
        JPanel buttonPanel = new JPanel();
        buttonPanel.add(confirmButton);
        buttonPanel.setBackground(Color.BLUE);
        frame.setLayout(new BorderLayout());
        frame.add(buttonPanel, BorderLayout.NORTH);
        frame.add(canvas);
        frame.add(grid);
        frame.setSize(650, 700);
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setVisible(true);
    }
}

class Grids extends RectangleCanvas {
    private List<Integer[]> centerCoordinates = new ArrayList<>();
    

    public Grids(RectangleCanvas canvas) {
        super();
        setFocusable(true);
 
    }

    @Override
    // Override paint component to create grid
    public void paintComponent(Graphics g) {
        super.paintComponent(g);

        // Variables
        final int rows = 11;
        final int columns = 11;
        final int startRowX = 50;
        final int startRowY = 100;
        final int startColX = 100;
        final int startColY = 50;
        final int cellSize = 50;
        final int endRowX = 600;
        final int endRowY = 100;
        final int endColX = 100;
        final int endColY = 600;

        final Color GridColor = Color.BLACK;

        // Creates the grids (row divider lines--horizontal)
        for (int i = 0; i < rows; i++) {
            g.setColor(GridColor);
            int NewStartY = startRowY + i * cellSize;
            int NewEndY = endRowY + i * cellSize;
            g.drawLine(startRowX, NewStartY, endRowX, NewEndY);
        }

        // Creates the grids (column divider lines-- vertical)
        for (int i = 0; i < columns; i++) {
            g.setColor(GridColor);
            int NewStartX = startColX + i * cellSize;
            int NewEndX = endColX + i * cellSize;
            g.drawLine(NewStartX, startColY, NewEndX, endColY);
        }

        // Iterates through rectangles and calculate center coordinates
        for (Rectangle rect : rectangles) {
            int centerX = rect.x + rect.width / 2;
            int centerY = rect.y + rect.height / 2;

            // Stores the center coordinates in the ArrayList
            Integer[] center = { centerX, centerY };
            centerCoordinates.add(center);
        }
    }

    // Added a method to get the center coordinates ArrayList
    public List<Integer[]> getCenterCoordinates() {
        return centerCoordinates;
    }
}

class RectangleCanvas extends JPanel implements MouseListener, MouseMotionListener {
    private Color RectColor = Color.MAGENTA;
    protected ArrayList<Rectangle> rectangles = new ArrayList<>();
    private Rectangle currentDraggedRectangle = null;
    private int otherX, otherY;
    private int clickCount = 0;
    private int gridSize = 50; // Size of each grid square
    private int gridWidth = 12; // Number of grid squares in the x-direction
    private int gridHeight = 12; // Number of grid squares in the y-direction
    private boolean isDraggable = true;
    
    public RectangleCanvas() {
        setBackground(Color.BLUE);
        addMouseListener(this);
        addMouseMotionListener(this);
        setFocusable(true);
    }

    public void setDraggable(boolean draggable) {
        isDraggable = draggable;
    }

    public void mousePressed(MouseEvent e) {
        if (isDraggable) {
            int x = e.getX();
            int y = e.getY();
            for (Rectangle rect : rectangles) {
                if (rect.contains(x, y)) {
                    currentDraggedRectangle = rect;
                    otherX = x - rect.x;
                    otherY = y - rect.y;
                    break;
                }
            }
        }
    }

    public void mouseReleased(MouseEvent e) {
        }

    public void mouseClicked(MouseEvent e) {
        if (isDraggable && clickCount < 4) {
            int x = (e.getX() / gridSize) * gridSize;
            int y = (e.getY() / gridSize) * gridSize;
            int width = (clickCount + 1) * gridSize;
            int height = gridSize;

            // Ensures that the rectangle stays within the grid boundaries
            if (x + width > gridWidth * gridSize) {
                x = (gridWidth - (clickCount + 1)) * gridSize;
            }
            if (y + height > gridHeight * gridSize) {
                y = (gridHeight - 1) * gridSize;
            }

            Rectangle newRect = new Rectangle(x, y, width, height);
            rectangles.add(newRect);
            clickCount++;
            repaint();
        }
    }

    public void mouseDragged(MouseEvent e) {
        if (currentDraggedRectangle != null) {
            int x = e.getX();
            int y = e.getY();
            int gridX = (x / gridSize) * gridSize;
            int gridY = (y / gridSize) * gridSize;

            // Ensures that the rectangle stays within the grid boundaries
            if (gridX + currentDraggedRectangle.width > gridWidth * gridSize) {
                gridX = (gridWidth - currentDraggedRectangle.width / gridSize) * gridSize;
            }
            if (gridY + currentDraggedRectangle.height > gridHeight * gridSize) {
                gridY = (gridHeight - currentDraggedRectangle.height / gridSize) * gridSize;
            }

            currentDraggedRectangle.setLocation(gridX, gridY);
            repaint();
            if (isRotateKeyPressed(e)) {
                int temp = currentDraggedRectangle.width;
                currentDraggedRectangle.width = currentDraggedRectangle.height;
                currentDraggedRectangle.height = temp;
            }

            repaint();
        }
    }
  
        private boolean isRotateKeyPressed(MouseEvent e) {
        	return e.isShiftDown();
        }
        public void paintComponent(Graphics g) {
        	super.paintComponent(g);
        	for (Rectangle rect : rectangles) {
        		g.setColor(RectColor);
        		g.fillRect(rect.x, rect.y, rect.width, rect.height);
        	}
        }
        
        public void mouseEntered(MouseEvent e) {
        }

        public void mouseExited(MouseEvent e) {
        }

        public void mouseMoved(MouseEvent e) {
        }
}
